// Posts module: Use a static snapshot generated at build time
// from dist/data/posts.json. No runtime DB calls.

export function getAuthorSlug(author: string): string {
  return author.toLowerCase().replace(/\s+/g, '-');
}

export function getProperAuthorName(slug: string): string {
  return slug.split('-').map(word => word.charAt(0).toUpperCase() + word.slice(1)).join(' ');
}

export interface Post {
  slug: string;
  path?: string;
  title: string;
  date: string;
  timezone: string;
  excerpt?: string;
  content: string;
  author: string;
  tags?: string[];
  thumbnail?: string;
  width?: 'small' | 'medium' | 'large';
  downloadUrl?: string;
}
// Internal: map a DB row to Post
type RowShape = Partial<Record<'path'|'slug'|'title'|'date'|'date_utc'|'timezone'|'excerpt'|'content'|'author'|'thumbnail'|'width'|'downloadUrl'|'download_url'|'tags', unknown>>;
function mapRowToPost(r: RowShape): Post {
  const rawDl = (r as Record<string, unknown>).downloadUrl ?? (r as Record<string, unknown>).download_url;
  let downloadUrl = rawDl == null ? undefined : String(rawDl);
  if (downloadUrl && /^(null|undefined)?$/i.test(downloadUrl.trim())) downloadUrl = undefined;
  let tags: string[] | undefined;
  if (r.tags != null) {
    try {
      if (typeof r.tags === 'string' && r.tags.trim().startsWith('[')) {
        tags = (JSON.parse(r.tags) as unknown[])
          .map(v => String(v).trim())
          .filter(s => s && !/^(null|undefined)$/i.test(s));
      } else if (Array.isArray(r.tags)) {
        const out: string[] = [];
        for (const v of (r.tags as unknown[])) {
          const s = String(v).trim();
          if (!s) continue;
          if (s.startsWith('[')) {
            try {
              const arr = JSON.parse(s) as unknown[];
              for (const a of arr) {
                const t = String(a).trim();
                if (t && !/^(null|undefined)$/i.test(t)) out.push(t);
              }
            } catch {
              out.push(s);
            }
          } else {
            out.push(s);
          }
        }
        tags = out.filter(Boolean);
      } else {
        const s = String(r.tags);
        const parts = (s.includes('||') ? s.split('||') : s.split(','));
        tags = parts.map(x => x.trim()).filter(x => x && !/^(null|undefined)$/i.test(x));
      }
      if (tags && tags.length) tags = Array.from(new Set(tags));
    } catch {
      tags = undefined;
    }
  }
  const slug = String(r.slug ?? '');
  const dateStr = String((r as Record<string, unknown>).date ?? (r as Record<string, unknown>).date_utc ?? '');
  let thumb: string | undefined = r.thumbnail ? String(r.thumbnail) : undefined;
  if (!thumb && slug && dateStr) {
    try {
      const cdn = (process.env.CDN_SITE && /^https?:\/\//.test(process.env.CDN_SITE)) ? process.env.CDN_SITE : 'https://cdn.dhugs.com';
      const d = new Date(dateStr);
      const y = d.getUTCFullYear();
      const m = String(d.getUTCMonth() + 1).padStart(2, '0');
      thumb = `${cdn}/o/${y}/${m}/${slug}/thumbnail.avif`;
    } catch {}
  }
  return {
    path: r.path ? String(r.path) : undefined,
    slug,
    title: String(r.title ?? ''),
    date: dateStr,
    timezone: String(r.timezone ?? ''),
    excerpt: r.excerpt ? String(r.excerpt) : undefined,
    content: r.content ? String(r.content) : '',
    tags,
    author: String(r.author ?? ''),
    thumbnail: thumb,
    width: (r.width ? String(r.width) : 'medium') as Post['width'],
    downloadUrl,
  };
}

// Static imports (bundled into server code)
// These files are generated by the content pipeline before build
// and are not publicly accessible.
import postsSnapshot from '../dist/data/posts.json';

// Simple in-memory cache for the request lifecycle
let allPostsCache: Post[] | null = null;
const singlePostCache = new Map<string, Post | null>();

export async function getAllPosts(): Promise<Post[]> {
  if (allPostsCache) return allPostsCache;
  try {
    const arr = (postsSnapshot as unknown as RowShape[]).map(mapRowToPost);
    allPostsCache = arr;
    return arr;
  } catch {
    throw new Error('posts snapshot missing. Run: npm run content:postsJson');
  }
}

export async function getPostByPath(pathSeg: string): Promise<Post | null> {
  if (singlePostCache.has(pathSeg)) return singlePostCache.get(pathSeg)!;
  const all = await getAllPosts();
  const hit = all.find(p => p.path === pathSeg) || null;
  singlePostCache.set(pathSeg, hit);
  return hit;
}
